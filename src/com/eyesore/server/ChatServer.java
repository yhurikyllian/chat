/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package com.eyesore.server;

import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Properties;

/**
 *
 * @author Sora
 */
public class ChatServer extends javax.swing.JFrame implements Runnable, CommonSettings{
    
    private Properties DBProperties;
    private ServerSocket serverSocket;
    private Socket socket;
    private ArrayList userArrayList,messageArrayList;
    private Thread thread;
    private ChatCommunication chatCommunication;	
    private DataOutputStream dataOutputStream;
    private int g_ILoop;
    private ClientObject clientObject;
    private String roomList;

    /**
     * Creates new form ChatServer
     */
    public ChatServer() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        btnOnAndOff = new javax.swing.JToggleButton();
        jLabel2 = new javax.swing.JLabel();
        lblStatus = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel1.setText("Kyllian Chat Server");

        btnOnAndOff.setText("ON/OFF");
        btnOnAndOff.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOnAndOffActionPerformed(evt);
            }
        });

        jLabel2.setText("Status :");

        lblStatus.setText("Server Disable");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblStatus))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(75, 75, 75)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(114, 114, 114)
                        .addComponent(btnOnAndOff)))
                .addContainerGap(76, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(41, 41, 41)
                .addComponent(btnOnAndOff)
                .addGap(54, 54, 54)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(lblStatus))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnOnAndOffActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOnAndOffActionPerformed
        // TODO add your handling code here:
        if(btnOnAndOff.isSelected()){
            DBProperties = getDBProperties();
                /*********Initialize the Server Socket*********/
            try {												
                roomList = "";
                if(DBProperties.getProperty("roomlist") != null) {
                    roomList = DBProperties.getProperty("roomlist");
                }

                int m_portNo = 1436;
                if(DBProperties.getProperty("portno") != null)
                        m_portNo = Integer.parseInt(DBProperties.getProperty("portno"));

                serverSocket = new ServerSocket(m_portNo);
            }catch(IOException _IOExc) { }

            /********Initialize the Array List**********/
            userArrayList = new ArrayList();
            messageArrayList = new ArrayList();	

            /********Initialize the thread*************/
            thread = new Thread(this);
            thread.start();

            lblStatus.setText("Server Enable");
        } else {
            exitServer();
            lblStatus.setText("Server Disable");
        }
    }//GEN-LAST:event_btnOnAndOffActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // TODO add your handling code here:
        exitServer();
        dispose();
        System.exit(0);
    }//GEN-LAST:event_formWindowClosing

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ChatServer().setVisible(true);
            }
        });
    }
    
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JToggleButton btnOnAndOff;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel lblStatus;
    // End of variables declaration//GEN-END:variables

    public void addUser(Socket clientSocket, String userName) {
        /***If User name Exists return**/
        if(IsUserExists(userName))
        {
            sendMessageToClient(clientSocket,"EXIS");
            return;	
        }

        /********Send a Room List ********/
        sendMessageToClient(clientSocket, "ROOM "+ roomList);

        /********Send the New User Detail into All Other Users****/					
        int m_userListSize = userArrayList.size();
        String m_addRFC = "ADD  "+ userName;
        StringBuffer stringBuffer = new StringBuffer("LIST ");
        
        for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
            clientObject = (ClientObject) userArrayList.get(g_ILoop);
            /***Check the Room Name*****/
            if(clientObject.getRoomName().equals(ROOM_NAME)) {
                sendMessageToClient(clientObject.getSocket(),m_addRFC);
                stringBuffer.append(clientObject.getUserName());													
                stringBuffer.append(";");									
            }
        }

        /*****Add a user in to array list***/
        clientObject = new ClientObject(clientSocket,userName,ROOM_NAME);
        userArrayList.add(clientObject);

        /********Sending the Complte User List to the New User***********/
        stringBuffer.append(userName);
        stringBuffer.append(";");
        sendMessageToClient(clientSocket,stringBuffer.toString());
    }

    void removeUser(String userName, String roomName, int removeType) {
        ClientObject removeClientObject = (ClientObject) getClientObject(userName);
		if(removeClientObject != null) {
			userArrayList.remove(removeClientObject);	
			userArrayList.trimToSize();
			int m_userListSize = userArrayList.size();
			String m_RemoveRFC = null;
			if(removeType == REMOVE_USER)
				 m_RemoveRFC = "REMO "+userName;
			if(removeType == KICK_USER)
				 m_RemoveRFC = "INKI "+userName;
			/*****Send a REMO RFC to all other Users****/
			for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
				clientObject = 	(ClientObject) userArrayList.get(g_ILoop);
				if(clientObject.getRoomName().equals(roomName))
					sendMessageToClient(clientObject.getSocket(),m_RemoveRFC);
			}			
		}	
    }

    void changeRoom(Socket clientSocket, String userName, String newRoomName) {
        int m_clientIndex = getIndexOf(userName);		
        if(m_clientIndex >= 0) {
            /********Update the Old Room to New Room and send the RFC**********/
            ClientObject tempClientObject = (ClientObject) userArrayList.get(m_clientIndex);
            String m_oldRoomName = tempClientObject.getRoomName();
            tempClientObject.setRoomName(newRoomName);
            userArrayList.set(m_clientIndex,tempClientObject);
            sendMessageToClient(clientSocket,"CHRO "+newRoomName);

            /****Send all the Users list of that particular room to that client socket****/
            int m_userListSize = userArrayList.size();
            StringBuffer stringBuffer = new StringBuffer("LIST ");			
            for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
                    clientObject = (ClientObject) userArrayList.get(g_ILoop);				
                    /***Check the Room Name*****/
                    if(clientObject.getRoomName().equals(newRoomName))
                    {					
                            stringBuffer.append(clientObject.getUserName());
                            stringBuffer.append(";");									
                    }
            }
            sendMessageToClient(clientSocket,stringBuffer.toString());


            /**********Inform to Old Room and New Room Users**********/			
            String m_OldRoomRFC = "LERO "+userName+"~"+newRoomName;
            String m_NewRoomRFC = "JORO "+userName;
            for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
                clientObject = (ClientObject) userArrayList.get(g_ILoop);
                if(clientObject.getRoomName().equals(m_oldRoomName))
                        sendMessageToClient(clientObject.getSocket(),m_OldRoomRFC);
                if((clientObject.getRoomName().equals(newRoomName)) && (!(clientObject.getUserName().equals(userName))))
                        sendMessageToClient(clientObject.getSocket(),m_NewRoomRFC);
            } 			
        }
    }

    void sendGeneralMessage(Socket clientSocket, String message, String userName,String roomName) {
        boolean m_floodFlag = false;
        messageArrayList.add(userName);		
        if(messageArrayList.size() > MAX_MESSAGE) {
            messageArrayList.remove(0);
            messageArrayList.trimToSize();

            /*********Chk Whether the User is flooding the message*********/
            String m_firstMessage = (String) messageArrayList.get(0);
            int m_messageListSize = messageArrayList.size();			
            for(g_ILoop = 1; g_ILoop < 	m_messageListSize; g_ILoop++) {
                if(messageArrayList.get(g_ILoop).equals(m_firstMessage)) {
                    m_floodFlag = true;
                }
                else {
                    m_floodFlag = false;
                    break;
                }	
            }						
        }

        /********Sending a General Message to All the Users*******/
        int m_userListSize = userArrayList.size();
        String m_messageRFC = "MESS "+userName+":"+message;
        for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
            clientObject = (ClientObject) userArrayList.get(g_ILoop);
            if((clientObject.getRoomName().equals(roomName)) && (!(clientObject.getUserName().equals(userName)))) {				
                sendMessageToClient(clientObject.getSocket(),m_messageRFC);	
            }	
        }

        /********Kick Off the User If he/she flooding the message********/
        if(m_floodFlag) {
                sendMessageToClient(clientSocket,"KICK ");
                messageArrayList.clear();		
        }
		
    }

    void sendPrivateMessage(String message, String toUserName) {
        clientObject = (ClientObject) getClientObject(toUserName);
        if(clientObject != null) {
            sendMessageToClient(clientObject.getSocket(),"PRIV "+message);	
        }
    }

    void getUserCount(Socket socket, String substring) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void requestForVoiceChat(Socket socket, String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void quitVoiceChat(String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void rejectCall(String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void sendUserIP(Socket socket, String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void getRemoteUserAddress(Socket socket, String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void sendRemoteUserAddress(Socket socket, String substring, String substring0) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void quitVideoChat(String substring) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    void removeUserWhenException(Socket clientSocket) {
        int m_userListSize = userArrayList.size();
        ClientObject removeClientObject;
        for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
            removeClientObject = (ClientObject) userArrayList.get(g_ILoop);
            if(removeClientObject.getSocket().equals(clientSocket)) {
                String m_removeuserName = removeClientObject.getUserName();
                String m_removeRoomName = removeClientObject.getRoomName();
                userArrayList.remove(removeClientObject);	
                userArrayList.trimToSize();					
                m_userListSize = userArrayList.size();
                String m_RemoveRFC="REMO "+m_removeuserName;

                /*****Send a REMO RFC to all other Users****/
                for(int m_ILoop = 0; m_ILoop < m_userListSize; m_ILoop++) {
                        clientObject = (ClientObject) userArrayList.get(m_ILoop);
                        if(clientObject.getRoomName().equals(m_removeRoomName))
                            sendMessageToClient(clientObject.getSocket(),m_RemoveRFC);
                }
                return;	
            }	
        }
    }
    
    private void exitServer() {
        if(thread != null) {
            thread.stop();
            thread = null;
        }
        try {
            if(serverSocket != null)
            {				
                    serverSocket.close();
                    serverSocket = null;
            }
        }catch(IOException _IOExc) { }
        
        userArrayList = null;
        messageArrayList = null;
    }

    private Properties getDBProperties() {
        /******************  Getting the Property Value From Propeyty File ************************/
        Properties DBProperties = new Properties();	
        try {			
            InputStream	inputstream = this.getClass().getClassLoader().getResourceAsStream("server.properties");
            DBProperties.load(inputstream);
            inputstream.close();
        }
        catch (IOException _IOExc){ }
        finally {
                return (DBProperties);
        }
    }

    @Override
    public void run() {
        /*********Accepting all the client connections and create a seperate thread******/
        while(thread != null) {
            try {
                /********Accepting the Server Connections***********/
                socket = serverSocket.accept();				
                /******* Create a Separate Thread for that each client**************/
                chatCommunication = new ChatCommunication(this,socket);

                thread.sleep(THREAD_SLEEP_TIME);	
            }
            catch(InterruptedException _INExc) {
                exitServer(); 
            }
            catch(IOException _IOExc) {
                exitServer();	
            }	
        }	
    }

    private boolean IsUserExists(String userName) {
        if(getClientObject(userName) != null)
            return true;
        else
            return false;
    }

    private void sendMessageToClient(Socket clientSocket, String message) {
        try {
            dataOutputStream = new DataOutputStream(clientSocket.getOutputStream());			
            dataOutputStream.write(new String(message+"\r\n").getBytes());
        }catch(IOException _IOExc) { }
    }

    private Object getClientObject(String userName) {
        ClientObject returnClientObject = null;
        ClientObject tempClientObject;
        int m_userListSize = userArrayList.size();
        for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
                tempClientObject = (ClientObject) userArrayList.get(g_ILoop);
                if(tempClientObject.getUserName().equalsIgnoreCase(userName)) {
                        returnClientObject = tempClientObject;
                        break;
                }
        }
        return returnClientObject;
    }

    private int getIndexOf(String userName) {
        int m_userListSize = userArrayList.size();
        for(g_ILoop = 0; g_ILoop < m_userListSize; g_ILoop++) {
            clientObject = (ClientObject) userArrayList.get(g_ILoop);
            if(clientObject.getUserName().equalsIgnoreCase(userName))
                    return g_ILoop;					
        }
        return -1;
    }
}
